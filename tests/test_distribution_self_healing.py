# tests/test_distribution_self_healing.py
import multiprocessing
import time
import iris

ADDR = "127.0.0.1:9010"
SERVICE_NAME = "reliable-worker"

def run_flapping_provider():
    """ Node B: The Flapping Service """
    def start_node():
        rt = iris.Runtime()
        rt.listen(ADDR)

        # This handler should only ever see user strings, never System Pings
        def logic(msg):
            print(f"üì© Provider received: {msg.decode()}")

        pid = rt.spawn(logic)
        rt.register(SERVICE_NAME, pid)
        print(f"üèóÔ∏è  Provider: Service '{SERVICE_NAME}' is LIVE.")

        # Stay alive long enough for a few heartbeats (1s interval)
        time.sleep(4)
        print("üèóÔ∏è  Provider: CRASHING NOW...")

    # Cycle 1
    p = multiprocessing.Process(target=start_node)
    p.start()
    p.join()

    print("üèóÔ∏è  Provider: NODE IS DOWN (Simulating network failure)...")
    time.sleep(3)

    # Cycle 2 (Restart)
    print("üèóÔ∏è  Provider: RESTARTING...")
    p = multiprocessing.Process(target=start_node)
    p.start()
    p.join()

def run_self_healing_monitor():
    """ Node A: The Resilient Observer """
    time.sleep(1)
    rt = iris.Runtime()

    def client_factory():
        print("üõ°Ô∏è  Supervisor: Factory attempting to restore service link...")
        while True:
            try:
                target_pid = rt.resolve_remote(ADDR, SERVICE_NAME)
                if target_pid:
                    # Proxy that forwards to the remote PID
                    def proxy_handler(msg):
                        rt.send_remote(ADDR, target_pid, msg)

                    # We use an observed handler locally to inspect system messages
                    local_pid = rt._inner.spawn_observed_handler(10)

                    # Attach the proxy logic via hot_swap or just use a simple handler
                    # For this test, we'll just track the local_pid
                    rt.monitor_remote(ADDR, target_pid)
                    print(f"üõ°Ô∏è  Supervisor: Link restored to PID {target_pid}")
                    return local_pid
            except Exception:
                pass
            time.sleep(0.5)

    # Supervise the connection
    dummy_pid = rt.spawn(lambda m: None)
    rt._inner.supervise_with_factory(dummy_pid, client_factory, "RestartOne")

    print("üî≠ Monitor: Self-healing loop active.")

    for i in range(20):
        children = rt._inner.child_pids()
        if children:
            current_child = children[0]
            rt.send(current_child, f"PING-{i}".encode())

            # Inspect messages to see if PING/PONG objects are arriving
            msgs = rt._inner.get_messages(current_child)
            for m in msgs:
                if isinstance(m, iris.PySystemMessage) and m.type_name in ["PING", "PONG"]:
                    # These are generated by the heartbeats in network.rs
                    pass

        time.sleep(0.5)

if __name__ == "__main__":
    print(f"--- Myrmidon Self-Healing & Heartbeat Test ---")
    p1 = multiprocessing.Process(target=run_flapping_provider)
    p2 = multiprocessing.Process(target=run_self_healing_monitor)

    p1.start()
    p2.start()

    p2.join()
    p1.terminate()
    print("‚ú® Self-healing test complete.")
